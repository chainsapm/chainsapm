<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
/****************************************************************************************
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChainsAPM.Commands.<#= this.Namespace #>
{
    public class <#= this.ClassName #> : Interfaces.ICommand<byte>
    {

         private Helpers.Fnv1a64 hashhelper;

         public DateTime TimeStamp { get; set; }
<# foreach (var enumn in this.EnumerationList)
{ #>
<# if (enumn.Flags){#>
        [Flags]
<#}#>
        public enum <#= enumn.EnumerationName #>
        {
<# foreach (var enumItem in enumn.Items)
{ #>
<# if (enumn.Items.Last().Name != enumItem.Name)
{ #>
            <#= enumItem.Name #> = 0x<#= enumItem.Value.ToString("x8") #>,
<#
} else { #>
            <#= enumItem.Name #> = 0x<#= enumItem.Value.ToString("x8") #>
<# } #>
<# } #>
        }
<# } #>

<# foreach (var cpItem in this.ClassProperties)
{ #>
        public <# if (TypeMapping.ContainsKey(cpItem.TypeName)) { if(cpItem.IsList == true) { #>List<<#}#><#=TypeMapping[cpItem.TypeName].ToString()#><#if(cpItem.IsList == true) { #>><#}#><#if(cpItem.IsArray == true){#>[]<#}#><# } else { if(cpItem.IsList == true) { #>List<<#}#><#= cpItem.TypeName.ToString()#><#if(cpItem.IsList == true) { #>><#}#><#if(cpItem.IsArray == true){#>[]<#}#><#}#> <#= cpItem.Name #> { get; set; }
<# } #>

        public <#= this.ClassName #>()
        {
            hashhelper = new Helpers.Fnv1a64();
        }

        public <#= this.ClassName #>(System.Int64 timestamp, <# foreach (var cpItem in this.ClassProperties) { if (TypeMapping.ContainsKey(cpItem.TypeName)) { if(cpItem.IsList == true) { #>List<<#}#><#=TypeMapping[cpItem.TypeName].ToString()#><#if(cpItem.IsList == true) { #>><#}#><#if(cpItem.IsArray == true){#>[]<#}#><# } else { if(cpItem.IsList == true) { #>List<<#}#><#= cpItem.TypeName.ToString()#><#if(cpItem.IsList == true) { #>><#}#><#if(cpItem.IsArray == true){#>[]<#}#><#}#> _<#= cpItem.Name.ToLower() #><#  if (this.ClassProperties.Last().Name != cpItem.Name) { #>, <# } else { } } #>) : this()
        {
                TimeStamp = timestamp == null ? DateTime.Now : DateTime.FromFileTimeUtc(timestamp);
<# foreach (var cpItem in this.ClassProperties)
{ #>
            <#= cpItem.Name #> = _<#= cpItem.Name.ToLower() #>;
<# } #>
        }

        public string Name
        {
            get { return "<#= this.Name #>"; }
        }
        public ushort Code
        {
            get { return 0x<#= this.Code.ToString("x4") #>; }
        }
        public string Description
        {
            get { return "<#= this.Description #>"; }
        }
        public Type CommandType
        {
            get { return typeof(<#= this.CommandType.ToString() #>); }
        }
        public Interfaces.ICommand<byte> Decode(ArraySegment<byte> input)
        {

            if (input.Count != 0)
            {
                Helpers.ArraySegmentStream segstream = new Helpers.ArraySegmentStream(input);
                int size = segstream.GetInt32();
                if (input.Count == size)
                {
                    short code = segstream.GetInt16();
                    if (code == Code)
                    {
                    var timestamp = segstream.GetInt64();
<# foreach (var cpItem in this.ClassProperties) { 
string typeName = "";
if (TypeMapping.ContainsKey(cpItem.TypeName)) { typeName = TypeMapping[cpItem.TypeName].ToString(); } else { typeName = cpItem.TypeName.ToString(); }
if (cpItem.IsList == true | cpItem.IsArray == true) { #>

                    var numberOf<#= cpItem.Name #> = segstream.GetInt32();
  <# if (cpItem.IsList == true) { #>
                    var listOf<#= cpItem.Name #> = new List<<#=typeName#>>();
  <# } else { #>
                    var arrayOf<#= cpItem.Name #> = new <#=typeName#>[numberOf<#= cpItem.Name #>];
  <# } #>
                    for (int i<#= cpItem.Name #> = 0; i<#= cpItem.Name #> < numberOf<#= cpItem.Name #>; i<#= cpItem.Name #>++)
                    {
<# } #>
<# if (typeName == typeof(string).FullName) { #>
                    var stringlen<#= cpItem.Name #> = segstream.GetInt32();
                    var decode<#= cpItem.Name #>Hash = segstream.GetInt64();
                    var decode<#= cpItem.Name #> = segstream.GetUnicode(stringlen<#= cpItem.Name #>);

<# } else if (typeName == typeof(Int32).FullName) { #>
                    var decode<#= cpItem.Name #> = segstream.GetInt32();

<# } else if (typeName == typeof(Int16).FullName) { #>
                    var decode<#= cpItem.Name #> = segstream.GetInt16();

<# } else if (typeName == typeof(Int64).FullName) { #>
                    var decode<#= cpItem.Name #> = segstream.GetInt64();

<# } else if (typeName == typeof(byte).FullName) { #>
                    var decode<#= cpItem.Name #> = segstream.GetByte();

<# } else { #>
                    var decode<#= cpItem.Name #> = (<#= typeName #>)segstream.GetInt32();

<# } #>
<# if (cpItem.IsList == true) { #>
                    listOf<#= cpItem.Name #>.Add(decode<#= cpItem.Name #>);
                    }
<# } else if (cpItem.IsArray == true) { #>
                    arrayOf<#= cpItem.Name #>[i<#= cpItem.Name #>] = decode<#= cpItem.Name #>;
                    }
<# } #>     
<# } #>                       
                    var term = segstream.GetInt16();

                    if (term != 0)
                    {
                        throw new System.Runtime.Serialization.SerializationException("Terminator is a non zero value. Please check the incoming byte stream for possible errors.");
                    }
                    return new <#= this.ClassName #>(timestamp, <# foreach (var cpItem in this.ClassProperties) { if(cpItem.IsList == true) { #>listOf<# } else if (cpItem.IsArray == true) { #>arrayOf<# } else { #>decode<# } #><#= cpItem.Name #><# if (this.ClassProperties.Last().Name != cpItem.Name) { #>, <# } else { } } #>);
                    }
                    else
                    {
                        throw new System.Runtime.Serialization.SerializationException("Invalid command code detected. Please check the incoming byte stream for possible errors.");
                    }
                }
                else
                {
                    throw new System.Runtime.Serialization.SerializationException("Size of message does not match size of byte stream. Please check the incoming byte stream for possible errors.");
                }
            }
            else
            {
                throw new System.Runtime.Serialization.SerializationException("Size of message is zero. Please check the incoming byte stream for possible errors. ");
            }
        }
        public byte[] Encode()
        {
            int byteSize = 0;

             byteSize += sizeof (Int32); // Length Of Command
             byteSize += sizeof (Int16); // Length Of Code
             byteSize += sizeof (Int64); // Length Of Timestamp

<# foreach (var cpItem in this.ClassProperties) { 
string typeName = "";			 
if (TypeMapping.ContainsKey(cpItem.TypeName)) { typeName = TypeMapping[cpItem.TypeName].ToString(); } else { typeName = cpItem.TypeName.ToString(); }
if (cpItem.IsList == true) { #>
            byteSize += 4; // Length of Array
<# } #>
<# if (typeName == typeof(string).FullName) { #>
<# if (cpItem.IsList == true) { #>
            foreach (var sItem in <#= cpItem.Name #>)
            {
               var sBufferListOfMethods_item = System.Text.UnicodeEncoding.Unicode.GetBytes (sItem);
               byteSize += sizeof(System.Int32); // Length Bytes
               byteSize += sizeof(System.Int64); // Hash Bytes
               byteSize += sBufferListOfMethods_item.Length + 1; // StringLength Bytes
            }
<# } else { #>
            byteSize += sizeof(System.Int32); // Length Bytes
            byteSize += sizeof(System.Int64); // Hash Bytes
            byteSize += <#= cpItem.Name #>.Length; // StringLength Bytes
<# } #>
<# } else if (typeName == typeof(Int32).FullName) { #>
            byteSize += sizeof(<#= typeName #>)<# if (cpItem.IsList == true) { #> * <#= cpItem.Name #>.Count<# } #><# if (cpItem.IsArray == true) { #> * <#= cpItem.Name #>.Length<# } #>;
<# } else if (typeName == typeof(Int16).FullName) { #>
            byteSize += sizeof(<#= typeName #>)<# if (cpItem.IsList == true) { #> * <#= cpItem.Name #>.Count<# } #><# if (cpItem.IsArray == true) { #> * <#= cpItem.Name #>.Length<# } #>;
<# } else if (typeName == typeof(Int64).FullName) { #>
            byteSize += sizeof(<#= typeName #>)<# if (cpItem.IsList == true) { #> * <#= cpItem.Name #>.Count<# } #><# if (cpItem.IsArray == true) { #> * <#= cpItem.Name #>.Length<# } #>;
<# } else if (typeName == typeof(byte).FullName) { #>
            byteSize += sizeof(<#= typeName #>)<# if (cpItem.IsList == true) { #> * <#= cpItem.Name #>.Count<# } #><# if (cpItem.IsArray == true) { #> * <#= cpItem.Name #>.Length<# } #>;
<# } else { #>
            byteSize += sizeof(Int32)<# if (cpItem.IsList == true) { #> * <#= cpItem.Name #>.Count<# } #><# if (cpItem.IsArray == true) { #> * <#= cpItem.Name #>.Length<# } #>;
<# } #>
<# } #>
            byteSize += sizeof (short); // Length Of Terminator
            var buffer = new List<byte>(byteSize);
            buffer.AddRange(BitConverter.GetBytes(byteSize)); // 4 bytes for size, 2 byte for code, 8 bytes for data, 8 bytes for data, 8 bytes for TS, 2 bytes for term
            buffer.AddRange(BitConverter.GetBytes(Code));
            buffer.AddRange(BitConverter.GetBytes(TimeStamp.ToFileTimeUtc()));
<# foreach (var cpItem in this.ClassProperties) {
string typeName = "";
if (TypeMapping.ContainsKey(cpItem.TypeName)) { typeName = TypeMapping[cpItem.TypeName].ToString(); } else { typeName = cpItem.TypeName.ToString(); }
if ((cpItem.IsList == true | cpItem.IsArray == true) && typeName != typeof(byte).FullName) { #>
<# if (cpItem.IsList == true) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>.Count)); // Count of List
<# } else { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>.Length)); // Length of Array
<# } #>
            foreach (var <#= cpItem.Name #>_item in <#= cpItem.Name #>)
            {
<# if (typeName == typeof(string).FullName) { #>
                var sBuffer<#= cpItem.Name #>_item = System.Text.UnicodeEncoding.Unicode.GetBytes(<#= cpItem.Name #>_item);
                buffer.AddRange(BitConverter.GetBytes(ListOfMethods_item.Length));
                buffer.AddRange(hashhelper.ComputeHash(sBuffer<#= cpItem.Name #>_item));
                buffer.AddRange(sBuffer<#= cpItem.Name #>_item);
                buffer.AddRange(BitConverter.GetBytes((short)0));
<# } else if (typeName == typeof(Int32).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>_item)); 
<# } else if (typeName == typeof(Int16).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>_item)); 
<# } else if (typeName == typeof(Int64).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>_item)); 
<# } else if (typeName == typeof(byte).FullName) { #>
<# } else { #>
                buffer.AddRange(BitConverter.GetBytes((int)<#= cpItem.Name #>_item)); 
<# } #>
            }

<# } else { #>
<# if (typeName == typeof(string).FullName) { #>
            var sBuffer<#= cpItem.Name #> = System.Text.UnicodeEncoding.Unicode.GetBytes(<#= cpItem.Name #>);
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>.Length + 1));
            buffer.AddRange(hashhelper.ComputeHash(sBuffer<#= cpItem.Name #>));
            buffer.AddRange(sBuffer<#= cpItem.Name #>);
            buffer.AddRange(BitConverter.GetBytes((short)0));
<# } else if (typeName == typeof(Int32).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>)); 
<# } else if (typeName == typeof(Int16).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>)); 
<# } else if (typeName == typeof(Int64).FullName) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>)); 
<# } else if (typeName == typeof(byte).FullName) { #>
<# if (cpItem.IsArray == true) { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>.Length)); // Length of Array
            buffer.AddRange(<#= cpItem.Name #>);  // Add raw bytes to stream
<# } else { #>
            buffer.AddRange(BitConverter.GetBytes(<#= cpItem.Name #>)); 
<# } #>
            
<# } else { #>
            buffer.AddRange(BitConverter.GetBytes((int)<#= cpItem.Name #>)); 
<# } #>

<# } #>
<# } #>
            buffer.AddRange(BitConverter.GetBytes((short)0));
            return buffer.ToArray();
        }
    }
    
}

