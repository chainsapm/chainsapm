<#@ template language="C#" #>  
<#@ assembly name="System.Core" #>  
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="SnippetIncludes.tt" #>
/**************************************************************************************** 
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
#pragma once
#include "stdafx.h"
#include "commands\\<#= this.ClassName #>.h"
 

namespace Commands
{
	<#= this.ClassName #>::<#= this.ClassName #>(__int64 timestamp, <# foreach (var cpItem in this.ClassProperties) { CreateCppSignature(cpItem, TypeMapping, this.ClassProperties.Last().Name != cpItem.Name); } #>)
		: timestamp(timestamp), code(0x<#= this.Code.ToString("x4") #>), hasEncoded(false), <# foreach (var cpItem in this.ClassProperties) { CreateCppInitializers(cpItem, this.ClassProperties.Last().Name != cpItem.Name); } #> 
	{
	}

	<#= this.ClassName #>::~<#= this.ClassName #>()
	{
	}

	std::wstring <#= this.ClassName #>::Name()
	{
		return L"<#= this.Name #>";
	}

	std::wstring <#= this.ClassName #>::Description()
	{
		return L"<#= this.Description #>";
	}

	std::shared_ptr<std::vector<char>> <#= this.ClassName #>::Encode()
	{
		if (!hasEncoded)
		{
			// The following items will be resued 
			auto hash = std::hash<std::wstring>();
			size_t hashout = 0;		// Temp var for string hashes
			size_t strlen = 0;		// Temp var for string length
			size_t strbytes = 0;	// Temp var for string bytes

			size_t size = sizeof(__int32)	// len
				+ sizeof(short)				// code
				+ sizeof(__int64);			// timestamp

			// Begin the dynamically generated sizes
<# PushIndent("			");
foreach (var cpItem in this.ClassProperties)
{ 
	if (cpItem.IsList == true | cpItem.IsArray == true) {
			CreateCppLengthListOrArray(cpItem, TypeMapping);  
	} else { 
			CreateCppLength(cpItem, TypeMapping);  
	} 
}
PopIndent(); 
#>
			// End the dynamically generated sizes  
			size += sizeof(short);	//Terminator

			auto vector = new char[size]; 
			short term = 0;
			
			// 
			auto v2 = (char*)memcpy(vector, &size, sizeof(__int32));  
			v2 += sizeof(__int32); 
			memcpy(v2, &code, sizeof(short));
			v2 += sizeof(short);
			memcpy(v2, &timestamp, sizeof(__int64));
			v2 += sizeof(__int64);

			// Begin the dynamically generated byte copies    
<# PushIndent("			");
foreach (var cpItem in this.ClassProperties)
{ 
	if (cpItem.IsList == true | cpItem.IsArray == true) {
			CreateCppDataInsertForList(cpItem, TypeMapping); 
	} else { 
			CreateCppDataInsert(cpItem, TypeMapping);
	}
}
PopIndent(); #>
			// End the dynamically generated byte copies

			// Terminator
			memcpy(v2, &term, sizeof(short));
			v2 += sizeof(short);

			hasEncoded = true;

			internalvector = std::make_shared<std::vector<char>>(vector, v2);
		}
		return internalvector;
	}

	std::shared_ptr<ICommand> <#= this.ClassName #>::Decode(std::shared_ptr<std::vector<char>> &data)      
	{
		auto hash = std::hash<std::wstring>();

		auto ptr = data->data();

		auto len = *(unsigned int*)ptr;  
		ptr += sizeof(unsigned int);

		auto code = *(short*)ptr;
		ptr += sizeof(short);

		auto local_timestamp = *(__int64*)ptr;
		ptr += sizeof(__int64);

<# PushIndent("		");
foreach (var cpItem in this.ClassProperties)
{ 
	if (cpItem.IsList == true | cpItem.IsArray == true) {
			ExtractCppDataForList(cpItem, TypeMapping); 
	} else { 
			ExtractCppData(cpItem, TypeMapping);  
	}
}
PopIndent(); #>

		// Terminator
		auto term = *(short*)ptr;
		ptr += sizeof(short);
		return std::make_shared<<#= this.ClassName #>>(local_timestamp, <# foreach (var cpItem in this.ClassProperties) { #> local_<#= cpItem.Name #> <#  if (this.ClassProperties.Last().Name != cpItem.Name) { #>, <# } else { } } #>);
	}
}

