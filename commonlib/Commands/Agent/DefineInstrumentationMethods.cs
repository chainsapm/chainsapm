/****************************************************************************************
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChainsAPM.Commands.Agent
{
    public class DefineInstrumentationMethods : Interfaces.ICommand<byte>
    {

         private Helpers.Fnv1a64 hashhelper;

         public DateTime TimeStamp { get; set; }

        public System.String AssemblyName { get; set; }
        public System.String TypeNameString { get; set; }
        public System.String MethodName { get; set; }
        public System.String InjectionMethodName { get; set; }
        public System.Byte[] InjectionMethodILBytes { get; set; }

        public DefineInstrumentationMethods()
        {
            hashhelper = new Helpers.Fnv1a64();
        }

        public DefineInstrumentationMethods(System.Int64 timestamp, System.String _assemblyname, System.String _typenamestring, System.String _methodname, System.String _injectionmethodname, System.Byte[] _injectionmethodilbytes) : this()
        {
            TimeStamp = timestamp == 0 ? DateTime.Now : DateTime.FromFileTimeUtc(timestamp);
            AssemblyName = _assemblyname;
            TypeNameString = _typenamestring;
            MethodName = _methodname;
            InjectionMethodName = _injectionmethodname;
            InjectionMethodILBytes = _injectionmethodilbytes;
        }

        public string Name
        {
            get { return "Define Instrumentation Method"; }
        }
        public ushort Code
        {
            get { return 0x0008; }
        }
        public string Description
        {
            get { return "This command will define a single instrumentation method."; }
        }
        public Type CommandType
        {
            get { return typeof(System.String); }
        }
        public Interfaces.ICommand<byte> Decode(ArraySegment<byte> input)
        {

            if (input.Count != 0)
            {
                Helpers.ArraySegmentStream segstream = new Helpers.ArraySegmentStream(input);
                int size = segstream.GetInt32();
                if (input.Count == size)
                {
                    short code = segstream.GetInt16();
                    if (code == Code)
                    {
                    var timestamp = segstream.GetInt64();
                    var stringlenAssemblyName = segstream.GetInt32();
                    var decodeAssemblyNameHash = segstream.GetInt64();
                    var decodeAssemblyName = segstream.GetUnicode(stringlenAssemblyName + 1);

     
                    var stringlenTypeNameString = segstream.GetInt32();
                    var decodeTypeNameStringHash = segstream.GetInt64();
                    var decodeTypeNameString = segstream.GetUnicode(stringlenTypeNameString + 1);

     
                    var stringlenMethodName = segstream.GetInt32();
                    var decodeMethodNameHash = segstream.GetInt64();
                    var decodeMethodName = segstream.GetUnicode(stringlenMethodName + 1);

     
                    var stringlenInjectionMethodName = segstream.GetInt32();
                    var decodeInjectionMethodNameHash = segstream.GetInt64();
                    var decodeInjectionMethodName = segstream.GetUnicode(stringlenInjectionMethodName + 1);

     

                    var numberOfInjectionMethodILBytes = segstream.GetInt32();
                      var arrayOfInjectionMethodILBytes = new System.Byte[numberOfInjectionMethodILBytes];
                      for (int iInjectionMethodILBytes = 0; iInjectionMethodILBytes < numberOfInjectionMethodILBytes; iInjectionMethodILBytes++)
                    {
                    var decodeInjectionMethodILBytes = segstream.GetByte();

                    arrayOfInjectionMethodILBytes[iInjectionMethodILBytes] = decodeInjectionMethodILBytes;
                    }
     
                       
                    var term = segstream.GetInt16();

                    if (term != 0)
                    {
                        throw new System.Runtime.Serialization.SerializationException("Terminator is a non zero value. Please check the incoming byte stream for possible errors.");
                    }
                    return new DefineInstrumentationMethods(timestamp, decodeAssemblyName, decodeTypeNameString, decodeMethodName, decodeInjectionMethodName, arrayOfInjectionMethodILBytes);
                    }
                    else
                    {
                        throw new System.Runtime.Serialization.SerializationException("Invalid command code detected. Please check the incoming byte stream for possible errors.");
                    }
                }
                else
                {
                    throw new System.Runtime.Serialization.SerializationException("Size of message does not match size of byte stream. Please check the incoming byte stream for possible errors.");
                }
            }
            else
            {
                throw new System.Runtime.Serialization.SerializationException("Size of message is zero. Please check the incoming byte stream for possible errors. ");
            }
        }
        public byte[] Encode()
        {
            int byteSize = 0;

             byteSize += sizeof (Int32); // Length Of Command
             byteSize += sizeof (Int16); // Length Of Code
             byteSize += sizeof (Int64); // Length Of Timestamp

            byteSize += sizeof(System.Int32); // Length Bytes
            byteSize += sizeof(System.Int64); // Hash Bytes
            byteSize += AssemblyName.Length; // StringLength Bytes
            byteSize += sizeof(System.Int16); // Zero Terminated String
            byteSize += sizeof(System.Int32); // Length Bytes
            byteSize += sizeof(System.Int64); // Hash Bytes
            byteSize += TypeNameString.Length; // StringLength Bytes
            byteSize += sizeof(System.Int16); // Zero Terminated String
            byteSize += sizeof(System.Int32); // Length Bytes
            byteSize += sizeof(System.Int64); // Hash Bytes
            byteSize += MethodName.Length; // StringLength Bytes
            byteSize += sizeof(System.Int16); // Zero Terminated String
            byteSize += sizeof(System.Int32); // Length Bytes
            byteSize += sizeof(System.Int64); // Hash Bytes
            byteSize += InjectionMethodName.Length; // StringLength Bytes
            byteSize += sizeof(System.Int16); // Zero Terminated String
             byteSize += sizeof (Int32);
            byteSize += sizeof(System.Byte) * InjectionMethodILBytes.Length;
            byteSize += sizeof (short); // Length Of Terminator
            var buffer = new List<byte>(byteSize);
            buffer.AddRange(BitConverter.GetBytes(byteSize)); // 4 bytes for size, 2 byte for code, 8 bytes for data, 8 bytes for data, 8 bytes for TS, 2 bytes for term
            buffer.AddRange(BitConverter.GetBytes(Code));
            buffer.AddRange(BitConverter.GetBytes(TimeStamp.ToFileTimeUtc()));
            var sBufferAssemblyName = System.Text.UnicodeEncoding.Unicode.GetBytes(AssemblyName);
            buffer.AddRange(BitConverter.GetBytes(AssemblyName.Length + 1));
            buffer.AddRange(hashhelper.ComputeHash(sBufferAssemblyName));
            buffer.AddRange(sBufferAssemblyName);
            buffer.AddRange(BitConverter.GetBytes((short)0));

            var sBufferTypeNameString = System.Text.UnicodeEncoding.Unicode.GetBytes(TypeNameString);
            buffer.AddRange(BitConverter.GetBytes(TypeNameString.Length + 1));
            buffer.AddRange(hashhelper.ComputeHash(sBufferTypeNameString));
            buffer.AddRange(sBufferTypeNameString);
            buffer.AddRange(BitConverter.GetBytes((short)0));

            var sBufferMethodName = System.Text.UnicodeEncoding.Unicode.GetBytes(MethodName);
            buffer.AddRange(BitConverter.GetBytes(MethodName.Length + 1));
            buffer.AddRange(hashhelper.ComputeHash(sBufferMethodName));
            buffer.AddRange(sBufferMethodName);
            buffer.AddRange(BitConverter.GetBytes((short)0));

            var sBufferInjectionMethodName = System.Text.UnicodeEncoding.Unicode.GetBytes(InjectionMethodName);
            buffer.AddRange(BitConverter.GetBytes(InjectionMethodName.Length + 1));
            buffer.AddRange(hashhelper.ComputeHash(sBufferInjectionMethodName));
            buffer.AddRange(sBufferInjectionMethodName);
            buffer.AddRange(BitConverter.GetBytes((short)0));

            buffer.AddRange(BitConverter.GetBytes(InjectionMethodILBytes.Length)); // Length of Array
            buffer.AddRange(InjectionMethodILBytes);  // Add raw bytes to stream
            

            buffer.AddRange(BitConverter.GetBytes((short)0));
            return buffer.ToArray();
        }
    }
    
}

