/****************************************************************************************
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChainsAPM.Commands.Agent
{
    public class MethodsToInstrument : Interfaces.ICommand<byte>
    {

         private Helpers.Fnv1a64 hashhelper;

         public DateTime TimeStamp { get; set; }
        public enum MethodProperties
        {
            Public = 0x00000001,
            Protected = 0x00000004,
            Private = 0x00000008,
            Friend = 0x00000010,
            Abstract = 0x00000020,
            Static = 0x00000040,
            IgnoreGetSet = 0x00000080,
            EntireClass = 0x00000100
        }

        public List<MethodProperties> MethodPropList { get; set; }
        public List<System.String> MethodClassList { get; set; }
        public List<System.String> MethodList { get; set; }

        public MethodsToInstrument()
        {
            hashhelper = new Helpers.Fnv1a64();
        }

        public MethodsToInstrument(System.Int64 timestamp, List<MethodProperties> _methodproplist, List<System.String> _methodclasslist, List<System.String> _methodlist) : this()
        {
            TimeStamp = timestamp == 0 ? DateTime.Now : DateTime.FromFileTimeUtc(timestamp);
            MethodPropList = _methodproplist;
            MethodClassList = _methodclasslist;
            MethodList = _methodlist;
        }

        public string Name
        {
            get { return "Methods To Instrument"; }
        }
        public ushort Code
        {
            get { return 0x0003; }
        }
        public string Description
        {
            get { return "Provides the Agent with a simple list of commands to instrument."; }
        }
        public Type CommandType
        {
            get { return typeof(System.String); }
        }
        public Interfaces.ICommand<byte> Decode(ArraySegment<byte> input)
        {

            if (input.Count != 0)
            {
                Helpers.ArraySegmentStream segstream = new Helpers.ArraySegmentStream(input);
                int size = segstream.GetInt32();
                if (input.Count == size)
                {
                    short code = segstream.GetInt16();
                    if (code == Code)
                    {
                    var timestamp = segstream.GetInt64();

                    var numberOfMethodPropList = segstream.GetInt32();
                      var listOfMethodPropList = new List<MethodProperties>();
                      for (int iMethodPropList = 0; iMethodPropList < numberOfMethodPropList; iMethodPropList++)
                    {
                    var decodeMethodPropList = (MethodProperties)segstream.GetInt32();

                    listOfMethodPropList.Add(decodeMethodPropList);
                    }
     

                    var numberOfMethodClassList = segstream.GetInt32();
                      var listOfMethodClassList = new List<System.String>();
                      for (int iMethodClassList = 0; iMethodClassList < numberOfMethodClassList; iMethodClassList++)
                    {
                    var stringlenMethodClassList = segstream.GetInt32();
                    var decodeMethodClassListHash = segstream.GetInt64();
                    var decodeMethodClassList = segstream.GetUnicode(stringlenMethodClassList + 1);

                    listOfMethodClassList.Add(decodeMethodClassList);
                    }
     

                    var numberOfMethodList = segstream.GetInt32();
                      var listOfMethodList = new List<System.String>();
                      for (int iMethodList = 0; iMethodList < numberOfMethodList; iMethodList++)
                    {
                    var stringlenMethodList = segstream.GetInt32();
                    var decodeMethodListHash = segstream.GetInt64();
                    var decodeMethodList = segstream.GetUnicode(stringlenMethodList + 1);

                    listOfMethodList.Add(decodeMethodList);
                    }
     
                       
                    var term = segstream.GetInt16();

                    if (term != 0)
                    {
                        throw new System.Runtime.Serialization.SerializationException("Terminator is a non zero value. Please check the incoming byte stream for possible errors.");
                    }
                    return new MethodsToInstrument(timestamp, listOfMethodPropList, listOfMethodClassList, listOfMethodList);
                    }
                    else
                    {
                        throw new System.Runtime.Serialization.SerializationException("Invalid command code detected. Please check the incoming byte stream for possible errors.");
                    }
                }
                else
                {
                    throw new System.Runtime.Serialization.SerializationException("Size of message does not match size of byte stream. Please check the incoming byte stream for possible errors.");
                }
            }
            else
            {
                throw new System.Runtime.Serialization.SerializationException("Size of message is zero. Please check the incoming byte stream for possible errors. ");
            }
        }
        public byte[] Encode()
        {
            int byteSize = 0;

             byteSize += sizeof (Int32); // Length Of Command
             byteSize += sizeof (Int16); // Length Of Code
             byteSize += sizeof (Int64); // Length Of Timestamp

            byteSize += 4; // Length of Array
			 byteSize += sizeof (Int32);
            byteSize += sizeof(Int32) * MethodPropList.Count;
            byteSize += 4; // Length of Array
            foreach (var sItem in MethodClassList)
            {
               var sBufferListOfMethods_item = System.Text.UnicodeEncoding.Unicode.GetBytes (sItem);
               byteSize += sizeof(System.Int32); // Length Bytes
               byteSize += sizeof(System.Int64); // Hash Bytes
               byteSize += sBufferListOfMethods_item.Length; // StringLength Bytes
               byteSize += sizeof(System.Int16); // Zero Terminated String
            }
            byteSize += 4; // Length of Array
            foreach (var sItem in MethodList)
            {
               var sBufferListOfMethods_item = System.Text.UnicodeEncoding.Unicode.GetBytes (sItem);
               byteSize += sizeof(System.Int32); // Length Bytes
               byteSize += sizeof(System.Int64); // Hash Bytes
               byteSize += sBufferListOfMethods_item.Length; // StringLength Bytes
               byteSize += sizeof(System.Int16); // Zero Terminated String
            }
            byteSize += sizeof (short); // Length Of Terminator
            var buffer = new List<byte>(byteSize);
            buffer.AddRange(BitConverter.GetBytes(byteSize)); // 4 bytes for size, 2 byte for code, 8 bytes for data, 8 bytes for data, 8 bytes for TS, 2 bytes for term
            buffer.AddRange(BitConverter.GetBytes(Code));
            buffer.AddRange(BitConverter.GetBytes(TimeStamp.ToFileTimeUtc()));
            buffer.AddRange(BitConverter.GetBytes(MethodPropList.Count)); // Count of List
            foreach (var MethodPropList_item in MethodPropList)
            {
                buffer.AddRange(BitConverter.GetBytes((int)MethodPropList_item)); 
            }

            buffer.AddRange(BitConverter.GetBytes(MethodClassList.Count)); // Count of List
            foreach (var MethodClassList_item in MethodClassList)
            {
                var sBufferMethodClassList_item = System.Text.UnicodeEncoding.Unicode.GetBytes(MethodClassList_item);
                buffer.AddRange(BitConverter.GetBytes(MethodClassList_item.Length + 1));
                buffer.AddRange(hashhelper.ComputeHash(sBufferMethodClassList_item));
                buffer.AddRange(sBufferMethodClassList_item);
                buffer.AddRange(BitConverter.GetBytes((short)0));
            }

            buffer.AddRange(BitConverter.GetBytes(MethodList.Count)); // Count of List
            foreach (var MethodList_item in MethodList)
            {
                var sBufferMethodList_item = System.Text.UnicodeEncoding.Unicode.GetBytes(MethodList_item);
                buffer.AddRange(BitConverter.GetBytes(MethodList_item.Length + 1));
                buffer.AddRange(hashhelper.ComputeHash(sBufferMethodList_item));
                buffer.AddRange(sBufferMethodList_item);
                buffer.AddRange(BitConverter.GetBytes((short)0));
            }

            buffer.AddRange(BitConverter.GetBytes((short)0));
            return buffer.ToArray();
        }
    }
    
}

