  
  
 

/**************************************************************************************** 
*
* This code was generated by the Command Creator tool for the ChainsAPM project. 
* If manual changes are made to the code they could be lost.
*
****************************************************************************************/
#pragma once
#include "stdafx.h"
#include "commands\MethodsToInstrument.h"
 

namespace Commands
{
	MethodsToInstrument::MethodsToInstrument(__int64 timestamp, std::vector<MethodProperties> methodproplist, std::vector<std::wstring> methodclasslist, std::vector<std::wstring> methodlist)
		: timestamp(timestamp), code(0x0003), hasEncoded(false), MethodPropList(methodproplist), MethodClassList(methodclasslist), MethodList(methodlist) 
	{
	}

	MethodsToInstrument::~MethodsToInstrument()
	{
	}

	std::wstring MethodsToInstrument::Name()
	{
		return L"Methods To Instrument";
	}

	std::wstring MethodsToInstrument::Description()
	{
		return L"Provides the Agent with a simple list of commands to instrument.";
	}

	std::shared_ptr<std::vector<char>> MethodsToInstrument::Encode()
	{
		if (!hasEncoded)
		{
			// The following items will be resued 
			auto hash = std::hash<std::wstring>();
			size_t hashout = 0;		// Temp var for string hashes
			size_t strlen = 0;		// Temp var for string length
			size_t strbytes = 0;	// Temp var for string bytes

			size_t size = sizeof(__int32)	// len
				+ sizeof(short)				// code
				+ sizeof(__int64);			// timestamp

			// Begin the dynamically generated sizes
			size += sizeof(MethodProperties) * MethodPropList.size(); // Size of MethodPropList vector
			
			
			size_t strlen_MethodClassListitemlen = 0;
			size_t strbytes_MethodClassListitemlen = 0;
			for (auto item : MethodClassList) {
			    strlen_MethodClassListitemlen = item.length();
			    strbytes_MethodClassListitemlen = (strlen_MethodClassListitemlen * sizeof(wchar_t)) + sizeof(wchar_t);
			    size += sizeof(__int32); // String Length 
			    size += sizeof(__int64); // String Hash
			    size += strbytes_MethodClassListitemlen; // String Bytes
			}

			
			size_t strlen_MethodListitemlen = 0;
			size_t strbytes_MethodListitemlen = 0;
			for (auto item : MethodList) {
			    strlen_MethodListitemlen = item.length();
			    strbytes_MethodListitemlen = (strlen_MethodListitemlen * sizeof(wchar_t)) + sizeof(wchar_t);
			    size += sizeof(__int32); // String Length 
			    size += sizeof(__int64); // String Hash
			    size += strbytes_MethodListitemlen; // String Bytes
			}

			// End the dynamically generated sizes  
			size += sizeof(short);	//Terminator

			auto vector = new char[size]; 
			short term = 0;
			
			// 
			auto v2 = (char*)memcpy(vector, &size, sizeof(__int32));  
			v2 += sizeof(__int32); 
			memcpy(v2, &code, sizeof(short));
			v2 += sizeof(short);
			memcpy(v2, &timestamp, sizeof(__int64));
			v2 += sizeof(__int64);

			// Begin the dynamically generated byte copies    
			
			for (auto item : MethodPropList) {
			     
			    memcpy(v2, &item, sizeof(MethodProperties));  
			    v2 += sizeof(MethodProperties); }

			
			size_t strlen_MethodClassListitemdata = 0;
			size_t strbytes_MethodClassListitemdata = 0;
			for (auto item : MethodClassList) {
			    strlen_MethodClassListitemdata = item.length();
			    strbytes_MethodClassListitemdata = (strlen_MethodClassListitemdata * sizeof(wchar_t)) + sizeof(wchar_t);
			    hashout = hash(item);
			     
			    
			    memcpy(v2, &strlen_MethodClassListitemdata, sizeof(__int32));
			    v2 += sizeof(__int32);
			    memcpy(v2, &hashout, sizeof(size_t));
			    v2 += sizeof(__int64);
			    memcpy(v2, item.data(), strbytes_MethodClassListitemdata);
			    v2 += strbytes_MethodClassListitemdata;
			}

			
			size_t strlen_MethodListitemdata = 0;
			size_t strbytes_MethodListitemdata = 0;
			for (auto item : MethodList) {
			    strlen_MethodListitemdata = item.length();
			    strbytes_MethodListitemdata = (strlen_MethodListitemdata * sizeof(wchar_t)) + sizeof(wchar_t);
			    hashout = hash(item);
			     
			    
			    memcpy(v2, &strlen_MethodListitemdata, sizeof(__int32));
			    v2 += sizeof(__int32);
			    memcpy(v2, &hashout, sizeof(size_t));
			    v2 += sizeof(__int64);
			    memcpy(v2, item.data(), strbytes_MethodListitemdata);
			    v2 += strbytes_MethodListitemdata;
			}

			// End the dynamically generated byte copies

			// Terminator
			memcpy(v2, &term, sizeof(short));
			v2 += sizeof(short);

			hasEncoded = true;

			internalvector = std::make_shared<std::vector<char>>(vector, v2);
		}
		return internalvector;
	}

	std::shared_ptr<ICommand> MethodsToInstrument::Decode(std::shared_ptr<std::vector<char>> &data)      
	{
		auto hash = std::hash<std::wstring>();

		auto ptr = data->data();

		auto len = *(unsigned int*)ptr;  
		ptr += sizeof(unsigned int);

		auto code = *(short*)ptr;
		ptr += sizeof(short);

		auto local_timestamp = *(__int64*)ptr;
		ptr += sizeof(__int64);

		
		size_t MethodPropList_count = *(__int32*)ptr;
		ptr += sizeof(__int32);
		
		auto local_MethodPropList = std::vector<MethodProperties>();
		
		for (size_t iMethodPropList = 0; iMethodPropList < MethodPropList_count; iMethodPropList++) {
		    auto value = *(MethodProperties*)ptr;
		    ptr += sizeof(MethodProperties); 
		    local_MethodPropList.emplace_back(value);
		}

		
		size_t MethodClassList_count = *(__int32*)ptr;
		ptr += sizeof(__int32);
		
		auto local_MethodClassList = std::vector<std::wstring>();
		
		for (size_t iMethodClassList = 0; iMethodClassList < MethodClassList_count; iMethodClassList++) {
		    
		    auto strlenMethodClassList = *(__int32*)ptr;
		    ptr += sizeof(__int32);
		    
		    auto hashMethodClassList = *(__int64*)ptr;
		    ptr += sizeof(__int64);
		    
		    auto str = (wchar_t*)ptr;
		    local_MethodClassList.emplace_back(str);
		    ptr += strlenMethodClassList * 2;
		}

		
		size_t MethodList_count = *(__int32*)ptr;
		ptr += sizeof(__int32);
		
		auto local_MethodList = std::vector<std::wstring>();
		
		for (size_t iMethodList = 0; iMethodList < MethodList_count; iMethodList++) {
		    
		    auto strlenMethodList = *(__int32*)ptr;
		    ptr += sizeof(__int32);
		    
		    auto hashMethodList = *(__int64*)ptr;
		    ptr += sizeof(__int64);
		    
		    auto str = (wchar_t*)ptr;
		    local_MethodList.emplace_back(str);
		    ptr += strlenMethodList * 2;
		}


		// Terminator
		auto term = *(short*)ptr;
		ptr += sizeof(short);
		return std::make_shared<MethodsToInstrument>(local_timestamp,  local_MethodPropList ,  local_MethodClassList ,  local_MethodList );
	}
}

